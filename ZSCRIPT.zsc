version "4.5"

class DSDHandler : EventHandler
{
	DSDStorage Storages[MAXPLAYERS];

	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'WildBackpack':
				if (random[dsdrand]() <= 64)
				{
					e.Replacement = "DSDInterface";
				}
				break;
		}
	}

	override void PlayerEntered(PlayerEvent e)
	{
		Storages[e.PlayerNumber] = DSDStorageThinker.Get(e.PlayerNumber);
	}

	// [Ace] I legitimately have no idea if this is even a good idea, but it seems to be the only way to manipulate the variables due to scoping.
	override void NetworkProcess(ConsoleEvent e)
	{
		let DSD = Storages[e.Player];

		if (e.Name ~== "DSD_BeginSearch")
		{
			DSD.InSearchMode = true;
			return;
		}

		if (e.Name ~== "DSD_ApplySearch")
		{
			DSD.ApplySearch();
			return;
		}

		if (e.Name ~== "DSD_DeleteLastChar")
		{
			DSD.SearchString.DeleteLastCharacter();
			return;
		}

		if (e.Name ~== "DSD_AppendChar")
		{
			DSD.SearchString = DSD.SearchString..String.Format("%c", e.Args[0]);
			return;
		}
	}

	override bool InputProcess(InputEvent e)
	{
		let plr = players[consoleplayer].mo;
		if (plr && plr.player && plr.player.ReadyWeapon is 'DSDInterface' && e.Type == e.Type_KeyDown)
		{
			if (!Storages[consoleplayer].InSearchMode && e.KeyScan == e.Key_Enter)
			{
				EventHandler.SendNetworkEvent("DSD_BeginSearch");
				return true;
			}
			else if (e.Type == e.Type_KeyDown && Storages[consoleplayer].InSearchMode)
			{
				switch (e.KeyScan)
				{
					// Apply filter.
					case e.Key_Enter:
						EventHandler.SendNetworkEvent("DSD_ApplySearch");
						break;

					// Delete last character.
					case e.Key_Backspace:
						EventHandler.SendNetworkEvent("DSD_DeleteLastChar");
						break;

					default:
						if (Storages[consoleplayer].SearchString.Length() < 20 && e.KeyChar >= 32 && e.KeyChar <= 126) // [Ace] Only valid characters.
						{
							EventHandler.SendNetworkEvent("DSD_AppendChar", e.KeyChar);
						}
						break;
				}
				return true;
			}
		}

		return false;
	}
}

class DSDStorage : ItemStorage
{
	void ApplySearch()
	{
		if (SearchString == "")
		{
			InSearchMode = false;
			return;
		}

		for (int i = 0; i < Items.Size(); ++i)
		{
			string NiceNameLower = Items[i].NiceName.MakeLower();
			SearchString = SearchString.MakeLower();
			if (NiceNameLower.IndexOf(SearchString) != -1)
			{
				SelItemIndex = i;
				break;
			}
		}
		SearchString = "";
		InSearchMode = false;
	}

	override string GetFailMessage()
	{
		return "Your storage is full.";
	}

	override int CheckConditions(Inventory item, class<Inventory> cls)
	{
		if (item)
		{
			let wpn = HDWeapon(item);
			let arm = HDArmour(item);
			let mag = HDMagAmmo(item);
			let pkp = HDPickup(item);

			if (item is 'HDBackpack')
			{
				return IType_Invalid;
			}
			if (wpn && !wpn.bNOINTERACTION && !wpn.bUNDROPPABLE && !wpn.bUNTOSSABLE && !wpn.bCHEATNOTWEAPON)
			{
				return IType_Weapon;
			}
			if (arm)
			{
				return IType_Armor;
			}
			if (mag)
			{
				return IType_Mag;
			}
			if (pkp && !pkp.bNOINTERACTION && !pkp.bUNDROPPABLE && !pkp.bUNTOSSABLE && pkp.bFITSINBACKPACK)
			{
				return IType_Pickup;
			}
		}
		else if (cls)
		{
			let wpn = cls is 'HDWeapon' ? GetDefaultByType((class<HDWeapon>)(cls)) : null;
			let arm = cls is 'HDArmour' ? GetDefaultByType((class<HDArmour>)(cls)) : null;
			let mag = cls is 'HDMagAmmo' ? GetDefaultByType((class<HDMagAmmo>)(cls)) : null;
			let pkp = cls is 'HDPickup' ? GetDefaultByType((class<HDPickup>)(cls)) : null;

			if (wpn && !wpn.bNOINTERACTION && !wpn.bUNDROPPABLE && !wpn.bUNTOSSABLE && !wpn.bCHEATNOTWEAPON && wpn.GetTag() != wpn.GetClassName())
			{
				return IType_Weapon;
			}
			if (arm && arm.GetTag() != arm.GetClassName())
			{
				return IType_Armor;
			}
			if (mag && mag.GetTag() != mag.GetClassName())
			{
				return IType_Mag;
			}
			if (pkp && !pkp.bNOINTERACTION && !pkp.bUNDROPPABLE && !pkp.bUNTOSSABLE && pkp.bFITSINBACKPACK && pkp.GetTag() != pkp.GetClassName())
			{
				return IType_Pickup;
			}
		}

		return IType_Invalid;
	}

	override Inventory RemoveItem(StorageItem item, Actor remover, Actor receiver, int amt, int index, int flags)
	{
		if (!item || item.Amounts.Size() == 0 || amt < 1)
		{
			return null;
		}

		let wpn = (class<HDWeapon>)(item.ItemClass);
		let arm = (class<HDArmour>)(item.ItemClass);
		let mag = (class<HDMagAmmo>)(item.ItemClass);
		let pkp = (class<HDPickup>)(item.ItemClass);

		Inventory Spawned = null;
		vector3 SpawnPos = (0, 0, 0);
		if (remover)
		{
			for (int i = 64; i >= 0; i -= 8)
			{
				SpawnPos = remover.Vec3Angle(i - 8, remover.angle, remover.height / 2 + 6);
				if (level.IsPointInLevel(SpawnPos))
				{
					break;
				}
			}
		}
		if (wpn)
		{
			index = min(index, item.Amounts.Size() - 1);
			amt = min(amt, item.Amounts[0]);
			if (remover && !(flags & BF_FROMCONSOLIDATE))
			{
				Actor.Spawn("DSDSpawnEffect", SpawnPos);
			}
			for (int i = 0; i < amt; ++i)
			{
				if (remover)
				{
					Spawned = Inventory(Actor.Spawn(wpn, SpawnPos));
					HDWeapon newwpn = HDWeapon(Spawned);
					for (int i = 0; i < HDWEP_STATUSSLOTS; ++i)
					{
						newwpn.WeaponStatus[i] = item.WeaponStatus[HDWEP_STATUSSLOTS * index + i];
					}
					if (newwpn.bDROPTRANSLATION)
					{
						newwpn.Translation = remover.Translation;
					}
					newwpn.A_ChangeVelocity(0, 0, frandom(0, 2), CVF_RELATIVE);
				}
				item.WeaponStatus.Delete(HDWEP_STATUSSLOTS * index, HDWEP_STATUSSLOTS);
				if (item.Icons.Size() > 1) // [Ace] Don't delete the last icon. It is used for the preview.
				{
					item.Icons.Delete(index);
				}
				item.Bulks.Delete(index);
				item.Amounts[0]--;
				if (item.Amounts[0] == 0)
				{
					item.Amounts.Delete(0);
				}
			}
		}
		else if (arm)
		{
			index = min(index, item.Amounts.Size() - 1);
			amt = min(amt, 1, item.Amounts.Size());
			if (remover && !(flags & BF_FROMCONSOLIDATE))
			{
				Actor.Spawn("DSDSpawnEffect", SpawnPos);
			}
			for (int i = 0; i < amt; ++i)
			{
				if (remover)
				{
					Spawned = Inventory(Actor.Spawn(arm, SpawnPos));
					HDArmour newarm = HDArmour(Spawned);
					newarm.Mags[0] = item.Amounts[0];
					newarm.angle = random(0, 359);
					newarm.A_ChangeVelocity(frandom(-0.1, 0.4), 0, frandom(0, 3), CVF_RELATIVE);
				}
				if (item.Icons.Size() > 1)
				{
					item.Icons.Delete(index);
				}
				item.Bulks.Delete(index);
				item.Amounts.Delete(index);
			}

		}
		else if (mag) // [Ace] Same shite. Mags and armor aren't in the same condition because of how icons are handled. I'd like to keep them separate.
		{
			index = min(index, item.Amounts.Size() - 1);
			amt = min(amt, item.Amounts.Size());
			if (remover && !(flags & BF_FROMCONSOLIDATE))
			{
				Actor.Spawn("DSDSpawnEffect", SpawnPos);
			}
			for (int i = 0; i < amt; ++i)
			{
				if (remover)
				{
					Spawned = Inventory(Actor.Spawn(mag, SpawnPos));
					HDMagAmmo newmag = HDMagAmmo(Spawned);
					newmag.Mags.Push(item.Amounts[0]);
					newmag.angle = random(0, 359);
					newmag.A_ChangeVelocity(frandom(-0.1, 0.4), 0, frandom(0, 3), CVF_RELATIVE);
				}
				item.Bulks.Delete(index);
				item.Amounts.Delete(index);
			}
		}
		else if (pkp)
		{
			amt = min(amt, item.Amounts[0]);
			if (remover)
			{
				if (!(flags & BF_FROMCONSOLIDATE))
				{
					Actor.Spawn("DSDSpawnEffect", SpawnPos);
				}
				Spawned = Inventory(Actor.Spawn(pkp, SpawnPos));
				HDPickup newpkp = HDPickup(Spawned);
				newpkp.Amount = amt;
				newpkp.angle = random(0, 359);
				newpkp.A_ChangeVelocity(frandom(-0.1, 0.4), 0, frandom(0, 3), CVF_RELATIVE);
			}
			item.Bulks[0] -= amt * GetDefaultByType(pkp).Bulk;
			item.Amounts[0] -= amt;
			if (item.Amounts[0] == 0)
			{
				item.Amounts.Delete(0);
			}
		}

		RemoveNullOrEmpty(remover);
		CalculateBulk();
		return Spawned;
	}

	string SearchString;
	bool InSearchMode;
}

class DSDStorageThinker : Thinker
{
	static DSDStorage Get(int num)
	{
		ThinkerIterator it = ThinkerIterator.Create('DSDStorageThinker', STAT_STATIC);
		DSDStorageThinker thkr;
		while ((thkr = DSDStorageThinker(it.Next())))
		{
			if (thkr.TrackedPlayer == num)
			{
				return thkr.Storage;
			}
		}

		// [Ace] Create a new one if none exist.
		thkr = new('DSDStorageThinker');
		thkr.ChangeStatNum(STAT_STATIC);
		thkr.TrackedPlayer = num;
		thkr.Storage = new('DSDStorage');
		thkr.Storage.MaxBulk = 2000;
		return thkr.Storage;
	}

	DSDStorage Storage;
	int TrackedPlayer;
}

class DSDInterface : HDBackpack
{
	enum DSDProperties
	{
		DSDProp_Flags
	}

	override void AttachToOwner(Actor other)
	{
		Super.AttachToOwner(other);

		Storage = DSDStorageThinker.Get(owner.PlayerNumber());

		// [Ace] I gotta set these here and not in LoadoutConfigure because that one is called before the storage can be initialized.
		if (StartingCapacity > 0)
		{
			Storage.MaxBulk = StartingCapacity;
			StartingCapacity = 0;
		}

		if (ConfigString != "")
		{
			// [Ace] Remove the dot after 'dsd', if any.
			if (ConfigString.ByteAt(0) == 46)
			{
				ConfigString = ConfigString.Mid(1);
			}
			Super.LoadoutConfigure(ConfigString);
			ConfigString = "";
		}
	}

	override void UpdateCapacity() {}
	override void DropOneAmmo(int amt) {}
	override void Consolidate() {}
	override void LoadoutConfigure(string input)
	{
		ConfigString = input;
		StartingCapacity = GetLoadoutVar(input, "cap", 5);
	}
	override bool CanGrabInsert(Inventory item, class<Inventory> item, Actor grabber) { return false; }
	override bool IsBeingWorn() { return false; }
	override string, double GetPickupSprite(){ return "DSDDA0", 1.0; }
	override double WeaponBulk()
	{
		return 80 + (Storage ? Storage.TotalBulk * 0.10 : 0);
	}

	override string GetHelpText()
	{
		return WEPHELP_FIRE.."/"..WEPHELP_ALTFIRE.."  Previous/Next item\n"
		..WEPHELP_FIREMODE.."+"..WEPHELP_UPDOWN.."  Adjust operation amount\n"
		..WEPHELP_RELOAD.."  Insert\n"
		..WEPHELP_UNLOAD.."  Remove\n"
		..WEPHELP_BTCOL.."Enter"..WEPHELP_RGCOL.."  Search mode/apply search";
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		int BaseOffset = -80;

		sb.DrawString(sb.pSmallFont, "\c[DarkBrown][] [] [] \c[Cyan]Dimensional Storage Device \c[DarkBrown][] [] []", (0, BaseOffset), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER);
		sb.DrawString(sb.pSmallFont, "Total Bulk: \cf"..int(Storage.TotalBulk).."/"..int(Storage.MaxBulk).."\c-", (0, BaseOffset + 10), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER);

		int ItemCount = Storage.Items.Size();

		if (ItemCount == 0)
		{
			sb.DrawString(sb.pSmallFont, "No items found.", (0, BaseOffset + 30), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, Font.CR_DARKGRAY);
			return;
		}
		
		StorageItem SelItem = Storage.GetSelectedItem();
		if (!SelItem)
		{
			return;
		}

		for (int i = 0; i < (ItemCount > 1 ? 5 : 1); ++i)
		{
			int RealIndex = (Storage.SelItemIndex + (i - 2)) % ItemCount;
			if (RealIndex < 0)
			{
				RealIndex = ItemCount - abs(RealIndex);
			}

			vector2 Offset = ItemCount > 1 ? (-100, 8) : (0, 0);
			switch (i)
			{
				case 1: Offset = (-50, 4);  break;
				case 2: Offset = (0, 0); break;
				case 3: Offset = (50, 4); break;
				case 4: Offset = (100, 8); break;
			}

			StorageItem CurItem = Storage.Items[RealIndex];
			bool CenterItem = Offset ~== (0, 0);
			sb.DrawImage(CurItem.Icons[0], (Offset.x, BaseOffset + 40 + Offset.y), sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER, CenterItem && !CurItem.HaveNone() ? 1.0 : 0.6, CenterItem ? (50, 30) : (30, 20), GetDefaultByType(CurItem.ItemClass).Scale * (CenterItem ? 4.0 : 3.0));
		}
		
		sb.DrawString(sb.pSmallFont, SelItem.NiceName, (0, BaseOffset + 60), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, Font.CR_FIRE);

		int AmountInBackpack = SelItem.ItemClass is 'HDMagAmmo' ? SelItem.Amounts.Size() : (SelItem.Amounts.Size() > 0 ? SelItem.Amounts[0] : 0);
		sb.DrawString(sb.pSmallFont, "In backpack:  "..sb.FormatNumber(AmountInBackpack, 1, 6), (0, BaseOffset + 70), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, AmountInBackpack > 0 ? Font.CR_BROWN : Font.CR_DARKBROWN);

		int AmountOnPerson = GetAmountOnPerson(hpl.FindInventory(SelItem.ItemClass));
		sb.DrawString(sb.pSmallFont, "On person:  "..sb.FormatNumber(AmountOnPerson, 1, 6), (0, BaseOffset + 78), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, AmountOnPerson > 0 ?  Font.CR_WHITE : Font.CR_DARKGRAY);

		if (SelItem.ItemClass is 'HDPickup' && !(SelItem.ItemClass is 'HDArmour'))
		{
			sb.DrawString(sb.pSmallFont, "Insert/remove:  "..sb.FormatNumber(OperationAmount, 1, 3), (0, BaseOffset + 86), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, Font.CR_SAPPHIRE);
		}

		if (DSDStorage(Storage).InSearchMode)
		{
			sb.DrawString(sb.pSmallFont, "Searching: "..DSDStorage(Storage).SearchString.."_", (-60, BaseOffset + 94), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
		}

		if (SelItem.ItemClass is 'HDArmour')
		{
			for (int i = 0; i < SelItem.Amounts.Size(); ++i)
			{
				vector2 Off = (-126 + 35 * (i % 8), BaseOffset + 110 + 35 * (i / 8));
				sb.DrawImage(SelItem.Icons[i], Off, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER, 1.0, (30, 20), (4.0, 4.0));
				sb.DrawString(sb.mAmountFont, sb.FormatNumber(SelItem.Amounts[i] > 1000 ? SelItem.Amounts[i] - 1000 : SelItem.Amounts[i], 1, 4), Off + (0, 12), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, Font.CR_YELLOW);
			}
		}
		else if (SelItem.ItemClass is 'HDMagAmmo' && !(SelItem.ItemClass is 'HDInjectorMaker'))
		{
			for (int i = 0; i < SelItem.Amounts.Size(); ++i)
			{
				vector2 Off = (-126 + 50 * (i / 10) - 2 * i, BaseOffset + 110 + 12 * (i % 10));
				sb.DrawImage(SelItem.Icons[0], Off, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER, OperationAmount > i ? 1.0 : 0.5, (10, 20), (4.0, 4.0));

				int MagAmt = SelItem.Amounts[i];
				if (MagAmt == 51 && SelItem.ItemClass is 'HD4mMag')
				{
					MagAmt = 50;
				}
				sb.DrawString(sb.mAmountFont, sb.FormatNumber(MagAmt, 1, 4), Off + (5, 3), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_YELLOW, OperationAmount > i ? 1.0 : 0.5);
			}
		}
		else if (SelItem.ItemClass is 'HDWeapon' && SelItem.Amounts.Size() > 0 && SelItem.Amounts[0] > 1)
		{
			// [Ace] Don't display the first weapon. It's already in the preview.
			for (int i = 1; i < SelItem.Amounts[0]; ++i)
			{
				vector2 Off = (-126 + 60 * ((i - 1) % 5), BaseOffset + 110 + 30 * ((i - 1) / 5));
				sb.DrawImage(SelItem.Icons[i], Off, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER, 1.0, (50, 20), (4.0, 4.0));
			}
		}
	}

	override void ActualPickup(Actor other, bool silent)
	{
		let DSD = DSDInterface(other.FindInventory("DSDInterface"));
		if (DSD && DSD.Storage)
		{
			other.A_StartSound("weapons/pocket");
			other.A_Log("Your storage has expanded.", true);
			DSD.Storage.MaxBulk += 1000;
			Destroy();
			return;
		}
		
		Super.ActualPickup(other, silent);
	}

	private int OperationAmount;
	private string ConfigString;
	private int StartingCapacity;

	Default
	{
		+INVENTORY.INVBAR
		+WEAPON.WIMPY_WEAPON
		-HDWEAPON.DROPTRANSLATION
		-HDWEAPON.FITSINBACKPACK
		+HDWEAPON.ALWAYSSHOWSTATUS
		+HDWEAPON.IGNORELOADOUTAMOUNT
		HDWeapon.WornLayer 0;
		Weapon.SelectionOrder 1010;
		Inventory.Icon "DSDDA0";
		Inventory.PickupMessage "Picked up a Dimensional Storage Device(tm). For the hoard!";
		Inventory.PickupSound "weapons/pocket";
		Tag "Dimensional Storage Device";
		HDWeapon.RefId "dsd";
		Scale 0.5;
	}
	
	States
	{
		Spawn:
			DSDD A -1;
			Stop;
		Select0:
			TNT1 A 1
			{
				invoker.OperationAmount = 1;
				A_UpdateStorage(); // [Ace] Populates items.
				A_StartSound("weapons/pocket", CHAN_WEAPON);
			}
			TNT1 A 0 A_Raise(999);
			Wait;
		Deselect0:
			TNT1 A 0 A_Lower(999);
			Wait;
		Ready:
			TNT1 A 1
			{
				if (PressingFiremode())
				{
					// [Ace] This code is copy-pasted from HD and I have no idea what all them bitshifts are supposed to do or why they're used in the first place.
					int InputAmount = GetMouseY(true);
					if (InputAmount != 0)
					{
						invoker.OperationAmount = clamp(invoker.OperationAmount + InputAmount / 20, 1, 100);
					}
					
				}
				else
				{
					invoker.RepeatTics--;
					A_WeaponReady(WRF_ALLOWUSER3);
					if (JustPressed(BT_ATTACK))
					{
						A_UpdateStorage();
						invoker.Storage.PrevItem();
					}
					else if (JustPressed(BT_ALTATTACK))
					{
						A_UpdateStorage();
						invoker.Storage.NextItem();
					}

					if (invoker.RepeatTics <= 0)
					{
						if (PressingReload())
						{
							A_UpdateStorage();
							StorageItem SelItem = invoker.Storage.GetSelectedItem();
							if (SelItem)
							{
								invoker.Storage.TryInsertItem(SelItem.InvRef, self, invoker.OperationAmount);
								invoker.RepeatTics = invoker.Storage.GetOperationSpeed(SelItem.ItemClass, true);
							}
						}
						else if (PressingUnload())
						{
							A_UpdateStorage();
							StorageItem SelItem = invoker.Storage.GetSelectedItem();
							if (SelItem)
							{
								invoker.Storage.RemoveItem(SelItem, self, null, invoker.OperationAmount);
								invoker.RepeatTics = invoker.Storage.GetOperationSpeed(SelItem.ItemClass, false);
							}
						}
					}
				}
			}
			Goto ReadyEnd;
		User3:
			TNT1 A 0 A_SelectWeapon("MagManager");
			Goto Ready;
	}
}

class DSDSpawnEffect : Actor
{
	Default
	{
		+NOINTERACTION
		Renderstyle "Add";
		Scale 0.5;
	}

	States
	{
		Spawn:
			DSDE A 0 NoDelay
			{
				A_StartSound("misc/teleport", pitch: 0.7);
				for (int i = 0; i < 150; ++i)
				{
					A_SpawnParticle(0x88BBFF, SPF_RELATIVE | SPF_FULLBRIGHT, random(8, 12), frandom(2, 3), random(0, 359), 32, 0, 0, -2, 0, frandom(3.5, 4));
					A_SpawnParticle(0x88BBFF, SPF_RELATIVE | SPF_FULLBRIGHT, random(8, 12), frandom(2, 3), random(0, 359), 32, 0, 0, -2, 0, -frandom(3.5, 4));
				}
			}
			DSDE ABABCDEFGHIJ 3 Bright;
			Stop;
	}
}