version "4.5"

class DSDHandler : EventHandler
{
	DSDStorage Storages[MAXPLAYERS];

	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'WildBackpack':
				if (random[dsdrand]() <= 20)
				{
					e.Replacement = "DSDInterface";
				}
				break;
		}
	}

	override void PlayerEntered(PlayerEvent e)
	{
		Storages[e.PlayerNumber] = DSDStorage.Get(e.PlayerNumber);
	}

	// [Ace] I legitimately have no idea if this is even a good idea, but it seems to be the only way to manipulate the variables due to scoping.
	override void NetworkProcess(ConsoleEvent e)
	{
		let DSD = Storages[e.Player];

		if (e.Name ~== "DSD_BeginSearch")
		{
			DSD.InSearchMode = true;
			return;
		}

		if (e.Name ~== "DSD_ApplySearch")
		{
			DSD.ApplySearch();
			return;
		}

		if (e.Name ~== "DSD_DeleteLastChar")
		{
			DSD.SearchString.DeleteLastCharacter();
			return;
		}

		if (e.Name ~== "DSD_AppendChar")
		{
			DSD.SearchString = DSD.SearchString..String.Format("%c", e.Args[0]);
			return;
		}
	}

	override bool InputProcess(InputEvent e)
	{
		let plr = players[consoleplayer].mo;
		if (plr && plr.player && plr.player.ReadyWeapon is 'DSDInterface' && e.Type == e.Type_KeyDown)
		{
			if (!Storages[consoleplayer].InSearchMode && e.KeyScan == e.Key_Enter)
			{
				EventHandler.SendNetworkEvent("DSD_BeginSearch");
				return true;
			}
			else if (e.Type == e.Type_KeyDown && Storages[consoleplayer].InSearchMode)
			{
				switch (e.KeyScan)
				{
					// Apply filter.
					case e.Key_Enter:
						EventHandler.SendNetworkEvent("DSD_ApplySearch");
						break;

					// Delete last character.
					case e.Key_Backspace:
						EventHandler.SendNetworkEvent("DSD_DeleteLastChar");
						break;

					default:
						if (Storages[consoleplayer].SearchString.Length() < 20 && e.KeyChar >= 32 && e.KeyChar <= 126) // [Ace] Only valid characters.
						{
							EventHandler.SendNetworkEvent("DSD_AppendChar", e.KeyChar);
						}
						break;
				}
				return true;
			}
		}

		return false;
	}
}

class DSDStorageItem play
{
	Inventory InvRef;
	class<Inventory> ItemClass;
	string NiceName;
	Array<string> Icons;
	Array<double> Bulks;
	Array<int> Amounts; // [Ace] Only one element (index 0) is used for singular items.
	Array<int> WeaponStatus; // [Ace] Every HDWEP_STATUSSLOTS starts a new weapon.

	clearscope double GetBulk()
	{
		double Total = 0;
		for (int i = 0; i < Bulks.Size(); ++i)
		{
			Total += Bulks[i];
		}
		return Total;
	}
}

class DSDStorage : Thinker
{
	static DSDStorage Get(int num)
	{
		ThinkerIterator it = ThinkerIterator.Create('DSDStorage', STAT_STATIC);
		DSDStorage Storage;
		while ((Storage = DSDStorage(it.Next())))
		{
			if (Storage.TrackedPlayer == num)
			{
				return Storage;
			}
		}

		// [Ace] Create a new one if none exist.
		Storage = new('DSDStorage');
		Storage.ChangeStatNum(STAT_STATIC);
		Storage.TrackedPlayer = num;
		return Storage;
	}

	// [Ace] Can also be used as "ClassifyItem". Multiuse!
	clearscope int CheckConditions(HDWeapon wpn, HDArmour arm, HDMagAmmo mag, HDPickup pkp)
	{
		if (wpn is 'HDBackpack')
		{
			return 0;
		}

		// [Ace] Easily extendable if more conditions need to be added later on.
		if (wpn && !wpn.bNOINTERACTION && !wpn.bDONTNULL && !wpn.bCHEATNOTWEAPON)
		{
			return 1;
		}
		else if (arm)
		{
			return 2;
		}
		else if (mag)
		{
			return 3;
		}
		else if (pkp && !pkp.bNOINTERACTION && !pkp.bUNDROPPABLE && !pkp.bUNTOSSABLE && pkp.bFITSINBACKPACK)
		{
			return 4;
		}

		return 0;
	}

	DSDStorageItem Find(class<Inventory> item)
	{
		for (int i = 0; i < Items.Size(); ++i)
		{
			if (Items[i].ItemClass == item)
			{
				return Items[i];
			}
		}

		return null;
	}

	void ApplySearch()
	{
		for (int i = 0; i < Items.Size(); ++i)
		{
			string NiceNameLower = Items[i].NiceName.MakeLower();
			SearchString = SearchString.MakeLower();
			if (NiceNameLower.IndexOf(SearchString) != -1)
			{
				SelItemIndex = i;
			}
		}
		SearchString = "";
		InSearchMode = false;
	}

	void PrevItem()
	{
		SelItemIndex--;
		if (SelItemIndex < 0)
		{
			SelItemIndex = Items.Size() - 1;
		}
	}

	void NextItem()
	{
		SelItemIndex++;
		if (SelItemIndex >= Items.Size())
		{
			SelItemIndex = 0;
		}
	}

	void ClampIndex()
	{
		SelItemIndex = clamp(SelItemIndex, 0, max(0, Items.Size() - 1));
	}

	clearscope DSDStorageItem GetSelectedItem()
	{
		if (Items.Size() > 0)
		{
			return Items[SelItemIndex];
		}

		return null;
	}

	// [Ace] noInsert means the item is only added temporarily and will be removed the next time RemoveEmpty is called.
	// Assuming you also don't have the item on you. That argument is used to populate the list with all items that are potentially backpackable.
	void TryInsertItem(Inventory item, bool noInsert, int amt = 1)
	{
		if (!item)
		{
			return;
		}

		let wpn = HDWeapon(item);
		let arm = HDArmour(item);
		let mag = HDMagAmmo(item);
		let pkp = HDPickup(item);
		let plr = players[TrackedPlayer].mo;
		
		int Type = CheckConditions(wpn, arm, mag, pkp);
		if (Type == 0)
		{
			return;
		}

		DSDStorageItem di = Find(item.GetClass());
		if (!di)
		{
			di = new('DSDStorageItem');
			Items.Push(di);
		}

		di.ItemClass = item.GetClass();
		di.NiceName = item.GetTag();
		di.InvRef = item;
		string Icon;
		switch (Type)
		{
			case 1:
				Icon = wpn.GetPickupSprite();
				break;
			case 2:
				Icon = arm.CheckMega() ? "ARMCA0" : "ARMSA0";
				break;
			case 3:
				Icon = mag.GetMagSprite(mag.MaxPerUnit);
				break;
		}

		// [Ace] Still empty? Fallback time.
		if (Icon == "")
		{
			Icon = TexMan.GetName(item.Icon);
			if (Icon == "") // [Ace] Persistent bastard, aren't ya?
			{
				Icon = TexMan.GetName(item.SpawnState.GetSpriteTexture(0));
			}
		}

		if (noInsert)
		{
			// [Ace] Only insert the icon for the purpose of displaying the item if it's not in the backpack yet.
			if (di.Icons.Size() == 0)
			{
				di.Icons.Push(Icon);
			}
			return;
		}

		switch (Type)
		{
			case 1:
				double WpnBulk = wpn.WeaponBulk();
				if (TotalBulk + WpnBulk >= MaxBulk)
				{
					plr.A_Log("Storage is too full.", true);
					break;
				}
				if (di.Amounts.Size() > 0 && di.Amounts[0] > 0) // [Ace] An icon already exists for preview purposes. Don't bother adding another one for the first element.
				{
					di.Icons.Push(Icon);
				}
				di.Bulks.Push(wpn.WeaponBulk());
				di.Amounts.Resize(1);
				di.Amounts[0]++;
				for (int i = 0; i < HDWEP_STATUSSLOTS; ++i)
				{
					di.WeaponStatus.Push(wpn.WeaponStatus[i]);
				}
				if (wpn.owner)
				{
					let plr = wpn.owner;
					wpn = HDWeapon(wpn.owner.DropInventory(wpn));
					di.InvRef = plr.FindInventory(wpn.GetClass()); // [Ace] Set the reference to the next weapon in your inventory.
					wpn.Amount--;
					if (wpn.Amount == 0)
					{
						wpn.Destroy();
					}
				}
				break;

			case 2:
				double ArmBulk = arm.CheckMega() ? ENC_BATTLEARMOUR : ENC_GARRISONARMOUR;
				if (TotalBulk + ArmBulk >= MaxBulk)
				{
					plr.A_Log("Storage is too full.", true);
					break;
				}
				if (di.Amounts.Size() > 0)
				{
					di.Icons.Push(Icon);
				}
				di.Bulks.Push(ArmBulk);
				di.Amounts.Push(arm.TakeMag(false));
				if (arm.Amount == 0)
				{
					arm.Destroy();
				}
				break;

			case 3:
				int MagCount = mag.Mags.Size();
				for (int i = 0; i < min(amt, MagCount); ++i)
				{
					double MagBulk = mag.MagBulk + mag.RoundBulk * (mag.Mags.Size() ? mag.Mags[mag.Mags.Size() - 1] : mag.MaxPerUnit);
					if (MagBulk == 0)
					{
						MagBulk = mag.Bulk;
					}
					if (TotalBulk + MagBulk >= MaxBulk)
					{
						plr.A_Log("Storage is too full.", true);
						break;
					}
					di.Icons.Resize(1);
					di.Icons[0] = Icon;
					di.Bulks.Push(MagBulk);
					di.Amounts.Push(mag.TakeMag(false));
					if (mag.Amount == 0)
					{
						mag.Destroy();
						break;
					}
				}
				break;
			case 4:
				int PickupCount = pkp.Amount;
				for (int i = 0; i < min(amt, PickupCount); ++i)
				{
					if (TotalBulk + pkp.Bulk >= MaxBulk)
					{
						plr.A_Log("Storage is too full.", true);
						break;
					}
					di.Icons.Resize(1);
					di.Icons[0] = Icon;
					di.Bulks.Resize(1);
					di.Bulks[0] += pkp.Bulk;
					di.Amounts.Resize(1);
					di.Amounts[0]++;
					pkp.Amount--;
					if (pkp.Amount == 0)
					{
						pkp.Destroy();
						break;
					}
				}
				break;
		}

		ClampIndex();
		CalculateBulk();
	}

	void RemoveItem(DSDStorageItem item, int amt = 1)
	{
		let wpn = (class<HDWeapon>)(item.ItemClass);
		let arm = (class<HDArmour>)(item.ItemClass);
		let mag = (class<HDMagAmmo>)(item.ItemClass);
		let pkp = (class<HDPickup>)(item.ItemClass);
		let plr = players[TrackedPlayer].mo;

		if (!plr || item.Amounts.Size() == 0)
		{
			return;
		}

		double SpawnHeight = plr.height / 2 + 6;
		vector3 SpawnPos = (0, 0, 0);
		for (int i = 64; i >= 0; i -= 8)
		{
			SpawnPos = plr.Vec3Angle(i, plr.angle, SpawnHeight);
			if (level.IsPointInLevel(SpawnPos))
			{
				break;
			}
		}
		if (wpn)
		{
			Actor.Spawn("DSDSpawnEffect", SpawnPos);
			HDWeapon newwpn = HDWeapon(Actor.Spawn(wpn, SpawnPos));
			newwpn.A_ChangeVelocity(0, 0, frandom(0, 2), CVF_RELATIVE);
			for (int i = 0; i < HDWEP_STATUSSLOTS; ++i)
			{
				newwpn.WeaponStatus[i] = item.WeaponStatus[i];
			}
			item.WeaponStatus.Delete(0, HDWEP_STATUSSLOTS);
			if (item.Icons.Size() > 1) // [Ace] Don't delete the last icon. It is used for the preview.
			{
				item.Icons.Delete(0);
			}
			item.Bulks.Delete(0);
			item.Amounts[0]--;
			if (item.Amounts[0] == 0)
			{
				item.Amounts.Pop();
			}
		}
		else if (arm)
		{
			Actor.Spawn("DSDSpawnEffect", SpawnPos);
			HDArmour newarm = HDArmour(Actor.Spawn(arm, SpawnPos));
			newarm.angle = random(0, 359);
			newarm.A_ChangeVelocity(frandom(-0.1, 0.4), 0, frandom(0, 3), CVF_RELATIVE);
			newarm.Mags[0] = item.Amounts[0];
			if (item.Icons.Size() > 1)
			{
				item.Icons.Delete(0);
			}
			item.Bulks.Delete(0);
			item.Amounts.Delete(0);
		}
		else if (mag) // [Ace] Same shite. Mags and armor aren't in the same condition because of how icons are handled. I'd like to keep them separate.
		{
			Actor.Spawn("DSDSpawnEffect", SpawnPos);
			int MagAmt = item.Amounts.Size();
			for (int i = 0; i < min(amt, MagAmt); ++i)
			{
				HDMagAmmo newmag = HDMagAmmo(Actor.Spawn(mag, SpawnPos));
				newmag.angle = random(0, 359);
				newmag.A_ChangeVelocity(frandom(-0.1, 0.4), 0, frandom(0, 3), CVF_RELATIVE);
				newmag.Mags.Push(item.Amounts[0]);
				item.Bulks.Delete(0);
				item.Amounts.Delete(0);
			}
		}
		else if (pkp)
		{
			Actor.Spawn("DSDSpawnEffect", SpawnPos);
			HDPickup newpkp = HDPickup(Actor.Spawn(pkp, SpawnPos));
			newpkp.A_ChangeVelocity(0, 0, frandom(0, 2), CVF_RELATIVE);
			amt = min(amt, item.Amounts[0]);
			newpkp.Amount = amt;
			item.Bulks[0] -= amt * newpkp.Bulk;
			item.Amounts[0] -= amt;
			if (item.Amounts[0] == 0)
			{
				item.Amounts.Delete(0);
			}
		}

		RemoveEmpty();
		CalculateBulk();
	}

	private void CalculateBulk()
	{
		TotalBulk = 0;
		for (int i = 0; i < Items.Size(); ++i)
		{
			TotalBulk += Items[i].GetBulk();
		}
	}

	void RemoveEmpty()
	{
		let plr = players[TrackedPlayer].mo;
		for (int i = 0; i < Items.Size();)
		{
			if (Items[i].Amounts.Size() == 0 && !plr.FindInventory(Items[i].ItemClass))
			{
				Items[i].Destroy();
				Items.Delete(i);
				continue;
			}
			i++;
		}
		ClampIndex();
	}

	double TotalBulk;
	int TrackedPlayer;
	int SelItemIndex;
	Array<DSDStorageItem> Items;
	string SearchString;
	bool InSearchMode;

	const MaxBulk = 10000;
}

// [Ace] I'm not using any of the backpack stuff. Everything is my own implementation.
// The real magic is upstairs.
class DSDInterface : HDWeapon
{
	enum DSDProperties
	{
		DSDProp_Flags
	}

	override void AttachToOwner(Actor other)
	{
		Super.AttachToOwner(other);
		InitStorage(); // [Ace] Only finds the thinker. Doesn not add any items.
	}

	private void InitStorage()
	{
		ItemStorage = DSDStorage.Get(owner.PlayerNumber());
	}

	// [Ace] This only populates the list with available items.
	private void UpdateStorage()
	{
		ItemStorage.RemoveEmpty(); // [Ace] Just in case you dropped something.
		Inventory Next = owner.Inv;
		while (Next)
		{
			ItemStorage.TryInsertItem(Next, true);
			Next = Next.Inv;
		}
	}

	override bool IsBeingWorn() { return true; }
	override string, double GetPickupSprite(){ return "DSDDA0", 1.0; }
	override double WeaponBulk()
	{
		return 80 + (ItemStorage ? ItemStorage.TotalBulk * 0.10 : 0);
	}
	override int DisplayAmount() { return int(ItemStorage.TotalBulk); }
	override int GetSbarNum()
	{
		int Percent = int(ItemStorage.TotalBulk * 100 / DSDStorage.MaxBulk);
		let sb = HDStatusBar(StatusBar);
		if (sb)
		{
			if (Percent > 80)
			{
				sb.savedcolour = Font.CR_RED;
			}
			else if (Percent > 60)
			{
				sb.savedcolour = Font.CR_YELLOW;
			}
			else if (Percent > 0)
			{
				sb.savedcolour = Font.CR_WHITE;
			}
		}
		return Percent;
	}
	override string GetHelpText()
	{
		return WEPHELP_FIRE.."/"..WEPHELP_ALTFIRE.."  Previous/Next item\n"
		..WEPHELP_FIREMODE.."+"..WEPHELP_UPDOWN.."  Adjust operation amount\n"
		..WEPHELP_RELOAD.."  Insert\n"
		..WEPHELP_BTCOL.."Enter"..WEPHELP_RGCOL.."  Search mode/apply search";
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		int BaseOffset = -80;

		sb.DrawString(sb.pSmallFont, "\c[DarkBrown][] [] [] \c[Cyan]Dimensional Storage Device \c[DarkBrown][] [] []", (0, BaseOffset), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER);
		sb.DrawString(sb.pSmallFont, "Total Bulk: \cf"..int(ItemStorage.TotalBulk).."\c-", (0, BaseOffset + 10), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER);

		int ItemCount = ItemStorage.Items.Size();

		if (ItemCount == 0)
		{
			sb.DrawString(sb.pSmallFont, "No items found.", (0, BaseOffset + 30), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, Font.CR_DARKGRAY);
			return;
		}
		
		DSDStorageItem SelItem = ItemStorage.GetSelectedItem();
		if (!SelItem)
		{
			return;
		}

		for (int i = 0; i < (ItemCount > 1 ? 5 : 1); ++i)
		{
			int RealIndex = (ItemStorage.SelItemIndex + (i - 2)) % ItemCount;
			if (RealIndex < 0)
			{
				RealIndex = ItemCount - abs(RealIndex);
			}

			vector2 Offset = ItemCount > 1 ? (-100, 8) : (0, 0);
			switch (i)
			{
				case 1: Offset = (-50, 4);  break;
				case 2: Offset = (0, 0); break;
				case 3: Offset = (50, 4); break;
				case 4: Offset = (100, 8); break;
			}

			DSDStorageItem CurItem = ItemStorage.Items[RealIndex];
			bool CenterItem = Offset ~== (0, 0);
			sb.DrawImage(CurItem.Icons[0], (Offset.x, BaseOffset + 40 + Offset.y), sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER, CenterItem ? 1.0 : 0.6, CenterItem ? (50, 30) : (30, 20), CenterItem ? (4.0, 4.0) : (3.0, 3.0));
		}
		
		sb.DrawString(sb.pSmallFont, SelItem.NiceName, (0, BaseOffset + 60), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, Font.CR_FIRE);

		int AmountInBackpack = SelItem.ItemClass is 'HDMagAmmo' ? SelItem.Amounts.Size() : (SelItem.Amounts.Size() > 0 ? SelItem.Amounts[0] : 0);
		sb.DrawString(sb.pSmallFont, "In backpack:  "..sb.FormatNumber(AmountInBackpack, 1, 6), (0, BaseOffset + 70), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, AmountInBackpack > 0 ? Font.CR_BROWN : Font.CR_DARKBROWN);

		int AmountOnPerson = GetAmountOnPerson(hpl.FindInventory(SelItem.ItemClass));
		sb.DrawString(sb.pSmallFont, "On person:  "..sb.FormatNumber(AmountOnPerson, 1, 6), (0, BaseOffset + 78), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, AmountOnPerson > 0 ?  Font.CR_WHITE : Font.CR_DARKGRAY);

		if (SelItem.ItemClass is 'HDPickup' && !(SelItem.ItemClass is 'HDArmour'))
		{
			sb.DrawString(sb.pSmallFont, "Insert/remove:  "..sb.FormatNumber(OperationAmount, 1, 3), (0, BaseOffset + 86), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, Font.CR_SAPPHIRE);
		}

		if (ItemStorage.InSearchMode)
		{
			sb.DrawString(sb.pSmallFont, "Searching: "..ItemStorage.SearchString.."_", (-60, BaseOffset + 94), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
		}

		if (SelItem.ItemClass is 'HDArmour')
		{
			for (int i = 0; i < SelItem.Amounts.Size(); ++i)
			{
				vector2 Off = (-126 + 35 * (i % 8), BaseOffset + 110 + 35 * (i / 8));
				sb.DrawImage(SelItem.Icons[i], Off, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER, 1.0, (30, 20), (4.0, 4.0));
				sb.DrawString(sb.mAmountFont, sb.FormatNumber(SelItem.Amounts[i] > 1000 ? SelItem.Amounts[i] - 1000 : SelItem.Amounts[i], 1, 4), Off + (0, 12), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER, Font.CR_YELLOW);
			}
		}
		else if (SelItem.ItemClass is 'HDMagAmmo' && !(SelItem.ItemClass is 'HDInjectorMaker'))
		{
			for (int i = 0; i < SelItem.Amounts.Size(); ++i)
			{
				vector2 Off = (-126 + 50 * (i / 10) - 2 * i, BaseOffset + 110 + 12 * (i % 10));
				sb.DrawImage(SelItem.Icons[0], Off, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER, OperationAmount > i ? 1.0 : 0.5, (10, 20), (4.0, 4.0));
				sb.DrawString(sb.mAmountFont, sb.FormatNumber(SelItem.Amounts[i], 1, 4), Off + (5, 3), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_YELLOW, OperationAmount > i ? 1.0 : 0.5);
			}
		}
		else if (SelItem.ItemClass is 'HDWeapon' && SelItem.Amounts.Size() > 0 && SelItem.Amounts[0] > 1)
		{
			// [Ace] Don't display the first weapon. It's already in the preview.
			for (int i = 1; i < SelItem.Amounts[0]; ++i)
			{
				vector2 Off = (-126 + 60 * (i % 5), BaseOffset + 110 + 30 * (i / 5));
				sb.DrawImage(SelItem.Icons[i], Off, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER, 1.0, (50, 20), (4.0, 4.0));
			}
		}
	}

	clearscope int GetAmountOnPerson(Inventory item)
	{
		let wpn = HDWeapon(item);
		let pkp = HDPickup(item);

		if (wpn)
		{
			return wpn.ActualAmount;
		}
		else if (pkp)
		{
			return pkp.Amount;
		}

		return 0;
	}

	private DSDStorage ItemStorage;
	private int OperationAmount;

	Default
	{
		+INVENTORY.INVBAR
		+WEAPON.WIMPY_WEAPON
		-HDWEAPON.DROPTRANSLATION
		-HDWEAPON.FITSINBACKPACK
		+HDWEAPON.ALWAYSSHOWSTATUS
		+HDWEAPON.IGNORELOADOUTAMOUNT
		+WEAPON.CHEATNOTWEAPON
		Weapon.SelectionOrder 1010;
		Inventory.Icon "DSDDA0";
		Inventory.PickupMessage "Picked up a Dimensional Storage Device(tm). For the hoard!";
		Inventory.PickupSound "weapons/pocket";
		Tag "Dimensional Storage Device";
		HDWeapon.RefId "dsd";
		Scale 0.5;
	}

	int RepeatTics;

	States
	{
		Spawn:
			DSDD A -1;
			Stop;
		Select0:
			TNT1 A 1
			{
				invoker.OperationAmount = 1;
				invoker.UpdateStorage(); // [Ace] Populates items.
				A_StartSound("weapons/pocket", CHAN_WEAPON);
			}
			TNT1 A 0 A_Raise(999);
			Wait;
		Deselect0:
			TNT1 A 0 A_Lower(999);
			Wait;
		Ready:
			TNT1 A 1
			{
				if (PressingFiremode())
				{
					// [Ace] This code is copy-pasted from HD and I have no idea what all them bitshifts are supposed to do or why they're used in the first place.
					int InputAmount = player.cmd.pitch;
					if(InputAmount)
					{
						if(abs(InputAmount) < (1 << 7))
						{
							InputAmount = clamp(InputAmount, -1, 1);
						}
						else
						{
							InputAmount >>= 7;
						}
					}
					InputAmount += (JustPressed(BT_ATTACK) ? 1 : JustPressed(BT_ALTATTACK) ? -1 : 0);
					HijackMouse();
					invoker.OperationAmount = clamp(invoker.OperationAmount + InputAmount, 1, 30);
				}
				else
				{
					invoker.RepeatTics--;
					A_WeaponReady(WRF_ALLOWUSER3);
					if (JustPressed(BT_ATTACK))
					{
						invoker.UpdateStorage();
						invoker.ItemStorage.PrevItem();
					}
					else if (JustPressed(BT_ALTATTACK))
					{
						invoker.UpdateStorage();
						invoker.ItemStorage.NextItem();
					}

					if (invoker.RepeatTics <= 0)
					{
						if (PressingReload())
						{
							invoker.UpdateStorage();
							DSDStorageItem SelItem = invoker.ItemStorage.GetSelectedItem();
							if (SelItem)
							{
								invoker.ItemStorage.TryInsertItem(SelItem.InvRef, false, invoker.OperationAmount);
								invoker.RepeatTics = 5;
							}
						}
						else if (PressingUnload())
						{
							invoker.UpdateStorage();
							DSDStorageItem SelItem = invoker.ItemStorage.GetSelectedItem();
							if (SelItem)
							{
								invoker.ItemStorage.RemoveItem(SelItem, invoker.OperationAmount);
								invoker.RepeatTics = 5;
							}
						}
					}
				}
			}
			Goto ReadyEnd;
		User3:
			TNT1 A 0 A_SelectWeapon("MagManager");
			Goto Ready;
	}
}

class DSDSpawnEffect : Actor
{
	Default
	{
		+NOINTERACTION
		Renderstyle "Add";
		Scale 0.5;
	}

	States
	{
		Spawn:
			DSDE A 0 NoDelay
			{
				A_StartSound("misc/teleport", pitch: 0.7);
				for (int i = 0; i < 150; ++i)
				{
					A_SpawnParticle(0x88BBFF, SPF_RELATIVE | SPF_FULLBRIGHT, random(8, 12), frandom(2, 3), random(0, 359), 32, 0, 0, -2, 0, frandom(3.5, 4));
					A_SpawnParticle(0x88BBFF, SPF_RELATIVE | SPF_FULLBRIGHT, random(8, 12), frandom(2, 3), random(0, 359), 32, 0, 0, -2, 0, -frandom(3.5, 4));
				}
			}
			DSDE ABABCDEFGHIJ 3 Bright;
			Stop;
	}
}